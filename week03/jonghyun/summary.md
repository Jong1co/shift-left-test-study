# Chapter 07

소프트웨어 품질을 보증하기 위한 목적으로 리팩터링을 해야 한다.

- 코드에 관한 본질론에서 리팩터링
- 익스트림 프로그래밍 실천방안으로서의 리팩터링
  - 익스트림 프로그래밍이란?

필자가 제안하는 리팩터링 흐름

1. 파ㄹ을 분리하여 전체 복잡도를 낮춘다.
2. 단위테스트를 작성한다.
3. mock을 작성한다.
4. 커버리지 비율을 측정하고, 커버리지 비율이 75%까지 테스트를 추가한다.
5. 리팩터링한다.

즉, 복잡도를 낮추고 출그를 하나로 통합하며, MVC를 분리하고 파일 코드를 단축하는 사항에 집중해야 함

**코드가 길어지는 이유**

- 책임과 의무가 적절하게 구분되지 않기 때문
- 일단 어딘가에 넣어두거나, 중복코드가 많을 경우, 규모가 큰 클래스에 의해 파일이 비대해질 경우

### 큰 클래스의 리팩터링

큰 클래스야말로 파일 코드를 길게 만드는 경우가 많음

- CK 지표란 ?
  - TODO: 질문 및 답변 추가
  - **WMC: 클래스당 평균 메서드 수**
    - 딱 정해진 것은 아니나, 메케이브 수 20, WMC 20 이하가 딱 적당함 (그렇다면 클래스당 메서드 수가 20개 이하이면 된다는 뜻인가)
  - DIT: 평균 클래스 상속 깊이
  - NOC: 평균 자식 클래스 수

CK 지표의 값이 클 때에는 반드시 리팩터링을 진행해야 함

WMC를 줄이기 위해서는 큰 클래스를 쪼개는 방식을 사용할 수 있음

1개의 큰 클래스가 2개의 적당히 큰 클래스가 되면 파일은 2개가 되고, 당연히 핫스팟 값이 줄어들게 됨.

### 복잡도를 낮추는 리팩터링

복잡도란 프로그램의 제어 흐름을 유효 그래프로 표현하고, 그 그래프가 가진 특성에 기반해 프로그램의 복잡성을 나타내는 방법.

- 복잡도가 높으면 버그가 증가하고, 단위테스트또한 작성하기 매우 어려움
- 복잡도가 클 경우, 수정을 진행해도 버그 혼용 확률이 아주 높음(40의 경우 50% 이상)

### 함수의 출구를 제한

- 출구가 두군데일 경우 반드시 입구에서 파라미터에 대한 에러 체크만 진행하며, 절대로 함수 안에서 return하지 않아야 함.

### MVC 분리

- MVC 분리는 최초 설계 단계에서 확실하게 고려하여 수행해야 하며, 뷰 영역에서 계산 관련 코드를 포함해서는 안 됨
- 이유는 뷰의 테스트는 사람이 보거나 GUI를 제어하는 자동 스크립트로 수행해야 하기 때문에 비용이 큼
  - 확실히 테스트 비용이 월등히 높음
  - 그렇다면 프론트엔드는 계산이 전혀 필요 없는가?
  - 프론트에서 테스트는 진행하지 않아도 되는가?
    - 이 부분에 대해서는 많이 찾아봤음. 확실히 프론트에 테스트는 필요없다는 의견이 월등히 많았음. 이유를 봤을 때 UI는 변경이 잦고, 테스트가 깨질 위험 또한 많기 때문임.
    - 내 의견: 그래도 테스트는 필요하다는 것이 내 의견임. 최근 프론트엔드에서도 화면의 복잡성이 높아지고, 그로 인해 계산을 아예 안 할 수는 없음. 그러나 화면 자체를 테스트 하는 것은 효율이 낮다고 생각함.
    - UI에 대한 테스트는 진행하지 않고, 로직에 대해서, 즉, UI가 아닌 UI를 다루는 함수 자체를 분리하여 순수 함수로써 테스트 하는 것이 옳다고 생각함.

# Chapter 08

**코드리뷰**

코드리뷰란 다른 사람이 작성한 코드를 지적하는 것이 아니라, 본인이 깨닫는 것에 중점을 두는 것

- 리뷰가 테스트보다 더 효율적인 버그 발견 방법이라는 의견
- 필자가 추천하는 것은 가능한 한 코드 리뷰 전에 기계가 검출할 수 있는 버그는 걸러내고, 사람은 정말 최소한의 작업만 하는 구조로 만드는 것
- 테스트가 실패하는 상태에서 리뷰를 진행해도 아무런 의미가 없음

**페어프로그래밍**

두 사람이 한 가지 일을 하는 만큼 단편적으로 생각하면 비용이 두 배로 늘어나는 기법이지만, 실행하는 방법에 따라 그 비용 부담을 크게 뛰어넘을 수 있는 기술

- 페어 프로그래밍은 개발자 레벨이 낮은 사람들에게서 더욱 효과적이고, 상급으로 갈 수록 적합하지 않다.
- 여러 논문에서 페어 프로그래밍은 확실히 소스 코드 품질을 높인다는 결과가 나타남.
- 96%의 개발자 또한 페어프로그래밍이 더 행복하다고 느낀다고 함
- 그렇기에 한번쯤은 시도해보는 것이 좋을듯

# Chapter 09

### 통합 테스트 패턴

- 단위테스트와 탐색적 테스트를 수행하고, 통합 테스트와 시스템 테스트를 수행하지 않음
- 단위 테스트, 통합 테스트, 시스템 테스트를 모두 확실하게 수행함(품질 중시 패턴)
- 단위 테스트를 수행하지 않고, 통합 테스트와 시스템 테스트를 수행함(후반 중시 패턴)

-> 필자의 경험에서 통합테스트 중시 설계도 꽤 잘 진행됨.(지금까지의 내용과 상반되는데?)

**통합 테스트 중시 설계 사례**

- 소프트웨어 아키텍처를 애플리케이션 계층, 미들웨어 계층으로 분리함
- 미들웨어 계층에서 api 테스트를하고, 미들웨어로부터 함수를 호출했으나,미들웨어에서 에러가 발생한다면 에러로 바로 튕겨져 나옴.
- 즉, 전제 조건이라 불리는 사전 상태를 적절하게 처리해야 내부까지 테스트 가능

-> 그래서 해당 팀에서는 단위 함수를 호출할 때 다른 함수와의 의존 관계를 최소화 하도록 설계했음 (그래서 성공한 것인가?)

**API 테스트와 API 버그 밀도에 관한 사고방식**

- API에 입력 파라미터가 있을 때는 그 파라미터에 대한 경곗값을 테스트하고, 가능한 한 해당 API를 다양한 형태로 호출한 뒤, 상태전이까지 커버할 수 있다면 완벽 !

-> 경곗값을 어느정도 커버했는지 측정하는 것이 관건 ! (책에서 계속 강조하는 경곗값 테스트..!)

-> 필자가 언급하는 API 커버리지 비율이 이해가 안 감.. 왜 마지막에는 5패턴 테스트케이스인가 ?

**카오스 엔지니어링**

- 시스템의 프로세스나 CPU, 가상머신 등을 무작위로 멈췄을 때 시스템 전체가 치명적인 상태에 빠지지 않도록 시스템을 설계하는 도구
- 돌연변이 테스트가 소스 코드 수준에서 부수는 것이라면, 시스템 레벨에서 부수는 것을 의미
- 비기능 테스트에 속함
- 비대해진 불안정한 시스템에서 시나리오 테스트는 통하지 않는다 !
- 자동화를 통해 효율적으로 수행할 수 있는 방법을 생각해야 함(시나리오 테스트는 무한에 가깝고, 무한에 가까운 테스트를 하더라도 전체 시나리오를 전부 망라하지 못하기 때문)

**카오스 엔지니어링의 목적**

넷플릭스에서 고안한 테스트로 목적은

1. 엔지니어가 다양한 서비스 실행 상황을 하나의 단일 시스템으로 다룰 수 있다.
2. 실제 입력값을 넣었을 때 시스템의 작동을 이해하고, 시스템 경계에서 무엇이 일어나는지 모니터링할 수 있다. (어떤 의미에서는 경곗값 테스트와 동일함)

**마이크로 서비스**

최근 마이크로 서비스가 유행하고 있고, 이는 애자일의 본질과 일치함

이유:

- 규모가 작은 팀일 수록 조기 버그 검출률이 높음
- 팀원 수가 늘어날수록 한 사람당 생산성이 낮아짐.

카오스 엔지니어링과 무슨 연관이 있나?

- 내 생각에는 마이크로 서비스로 분리하고, 이 각각의 서비스를 카오스 멍키 테스트를 통해 부수고 실행하고 하면 오류 검출도 빠르고, 수정도 빠르기 때문..?
- 그리고 앞에 내용들을 함께 보았을 때, 작게 서비스를 분리하면 코드 자체도 목적이 명확해지고, 코드 양도 작아지기 때문이지 않을까..?(큰 클래스 리팩터링과 같은 관점으로)
