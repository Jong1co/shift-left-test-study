(검색이 어려워서 제가 보려고 만든 전체 요약본)

테스트 시작하기
=============

## 1.1 시프트-레프트의 개요

- 조기 품질 = 시프트-레프트
  - 전체 개발 과정에서 품질을 향상하는 활동을 조기에 설계하는 것 -> 기존에는 품질 검사를 개발/빌드가 끝나고나서 했음
  - 시프트-레프트하다 = 애자일에서의 품질 보증이 될 것, 조기 품질 향상을 목적으로 둘 것

## 1.2 애자일에서의 품질

- 그래서 스크럼이란?
  - 중첩된 개발 단계, 다중 학습, 유연한 관리 체계, 조직내 학습 공유
  - 다양한 기능을 가진 팀이 처음부터 마지막까지 함게 작업 = 그러니까 테스트 담당자도 개발자도 AtoZ 함께하는 것
  - 개발하고 -> 개발끝나면 테스트하고 이게 아니라 서로 유기적으로 행동

- 애자일한 테스트
  - 작업 지침용 상자
  - 개발자의 구체적인 작업 지침 = 지표를 어떻게 달성할지에 관한 구체적 활동, 예를 들어 개발자 테스트에서 일정 수준 이상의 코드 커버리지 비율 달성
  - 테스트 담당자의 구체적인 작업 지침 = 애자일에서는 시스템 테스트 활동 정의X니까 각 조직이 정의 해야함(이게맞나) -> 데이터 기반의 시스템 테스트를 정의해야함

시프트-레프트 테스트
=============

- 모든 단계의 버그를 시스템 테스트로 해결하지 말 것
    -> 사실 애자일에서도 마지막 테스트&유지보수 상태에서 버그를 시스템 테스트로 잡아내려하는데, 이것도 혼돈상태라고 봐야함
    - 왜냐? **제품 개발 과정에서 테스트가 제일 분주한 시점일텐데 이걸 후반부에 두어 일정에 쫓겨 릴리스 한다는 건 결국 리스크이기 때문**
    - 다른 공학 계열에서 어떻게 테스트를 하는지 대입해 생각해볼 것 -> 예를 들어 제조업에서 각 부품의 신뢰성을 확인하지도 않고 갑자기 완제품을 테스트 해보진 않듯이, 소프트웨어도 각각의 단위 테스트도 진행하지 않은 상태에서 통합 테스트를 진행하는 것은 생산적이지 못함

Q) 개인적인 의문
1. 그러면 애자일하게 일을 진행하는 팀에서는 테스트를 전부 코딩후에 하는건가?
2. 테스트코드를 작성하는 것만으로는 커버가 안되는건가? -> 개발자가 코드작성, 테스트 담당자가 테스트코드 작성등으로는 커버 불가능?

## 2.1 시프트-레프트 모델

- 그래서 조기 품질을 높이기 위한 시프트-레프트 모델이란?
  - 요구 사항 및 사용자 스토리의 명확화
  - 클래스나 함수 구조를 간단히 유지
  - 단위 및 통합 테스트 실행
  - 리뷰 실시

Q) 사용자 스토리의 명확화라는건 페르소나 얘기하는건가?


## 2.2 시프트-레프트 테스트 특징

사실상 모든 조직은 아래와 같은 딜레마를 안고 있음 

1. 경영진은 시프트-레프트로 품질 보증을 원하나 엔지니어들이 바쁘다고 회피함
2. (회피라곤 했지만..) 실제로 엔지니어들은 바쁨

**그러나 수치적으로 조기 단계에서에서 품질을 보증하는 편이 출시 후의 품질을 높이는 지름길**
결론적으로 후반 단계에서 버그를 찾아내도 출시 후의 오류를 줄이는 데는 한계가 있음. 통합 테스트에서 발견하는 버그는 많아봐야 40%이고 조기단계에서 발견할 수 있는 버그는 85%

Q) 구체적으로 조기단계에서 발견할 수 있는 버그라는게 뭐지? 설계상의 오류를 뜻하는 것같음..

조기 코드 인스펙션, 리뷰, 반복 개발, 주기적 구축 등에 중점을 두면 결함 추출 곡선은 개발 초기 단계로 이동함

![alt text](week01/image.png)

그래서 코드리뷰나 인스펙션을 충분히 실시해서 통합 테스트나 시스템 테스트에서 발견되지 않도록 해야함!

- 프로젝트 후반에 버그를 없애는 비용은 전반에 드는 비용의 수 배에 달함 -> 효율 낮음 = 비용 발생
- 프로젝트 후반에 버그를 없애려고하면 해결되지 않은 버그가 출시 후에 남겨질 리스크 또한 존재

전문적으로 얘기하자면 개발 단계가 뒤로 갈수록 버그 수정에 드는 공수가 기하급수적으로 올라감 (요구사항에서 1의 난이도라면 출시후엔 100의 난이도인셈)

PS) 그런데 코드 인스펙션이 뭐야? (참조 : https://dataonair.or.kr/db-tech-reference/d-lounge/expert-column/?mod=document&uid=54455)

![alt text](week01/image-1.png)

![alt text](week01/image-2.png)

코드 인스펙션 = 코드 정적 분석, 그러니까 실행해서 코드가 잘 돌아가는지 확인하는게 아니라 구문 오류가 있는지 논리적으로 맞는지 툴을 이용해 분석하는 것 -> 그냥 별거 아니고 우리가 아는 ESLint, IntelliJ Inspection 이런거임

PS) 이터레이션이란? 이터레이션은 개발 과정을 나타내는 데 사용되는 용어로, 특히 애자일 개발 방법론에서 각 개발 사이클 또는 단계를 의미 (고마워 따봉 GPT야!)



개발자 테스트의 기본 중 기본
=============

### **적어도 클래스 다이어그램과 시퀀스 다이어그램만은 작성하라!** 
->  왜냐?클래스 다이어그램이 있으면 큰 클래스를 방지할 수 있고 리팩터링의 효과도 시각화 할 수 있음

## 3.1 개발자가 반드시 알아야 할 테스트 기법

### 소프트웨어 개발 시 수행하는 테스트 목록

- 단위 테스트
- 조합 테스트
- 경곗값 테스트
- 상태 전이 테스트
- 탐색적 테스트
- 통합 테스트
- 시스템 테스트

모든 테스트를 수행할 수 없으므로
테스트 **라이프 사이클(단위 -> 통합 -> 시스템)** 의 각 단계에 맞춰 적절한 **테스트 방법(경곗값/조합/상태 전이)** 를 수행해야함

### 단위 테스트에서 이해해야할 3가지 기법

1. **경곗값 테스트 : 문자 그대로 경계를 테스트하는 방법**

    예를 들어
    어떤 시스템이나 애플리케이션이 나이를 입력 받아, 나이가 18세 이상 65세 이하인 경우만 "적합"으로 판단하는 기능을 가지고 있다고 할때  
    
    이 경우의 경계값은 18세와 65세. 그러므로 경계값 테스트에서는 이 경계값들 주변의 값을 사용하여 테스트 케이스를 만듬. 일반적으로 다음과 같은 값들을 테스트에 포함

    - 경계값 바로 아래의 값: 17세  
    - 경계값 자체: 18세, 65세  
    - 경계값 바로 위의 값: 66세

    이 경우 발생하는 버그 네가지

    - 올바른 코드
    ```
    if(a>=18 && b<=65){
        // 출력
    }else {
        // 에러 처리
    }
    ```

    - 닫힘 관계 버그 : >= 로 입력해야하는데 >라고 잘못 입력한 경우
    ```
    if(a>18 && b<65){
        // 출력
    }else {
        // 에러 처리
    }
    ```

    - 잘못 입력한 숫자, 요구사항 사양 오해 : 수 자체를 잘못 입력
    ```
    if(a>19 && b<64){
        // 출력
    }else {
        // 에러 처리
    }
    ```

    - 경계가 없음 : 조건문 작성하는 것을 잊은 경우
    ```
    if(a>=18 && b<=65){
        // 출력
    } // 이외의 예외를 처리하지 않음
    ```

    - 여분의 경계 : 불필요한 경계를 개발자가 작성함
    ```
    if(a>=18 && b<=65 && b>100){
        // 출력
    }else {
        // 에러 처리
    }
    ```
  
2. **상태 전이 테스트**

    '상태'를 모델화해서 테스트를 수행하는 방법. 크게 **상태**와 **전이**로 나뉨

    예시 (출처 : https://story.pxd.co.kr/1549)

    **애플리케이션 상태**  
    ![alt text](week01/image-3.png)

    **상태 전이 매트릭스**  
    ![alt text](week01/image-4.png)

    상태 전이 매트릭스에서 설계상 그런 이벤트가 발생하지 않을때 NA로 표시하는 것
    예를 들어 여기선 배송 중일때 반품을 할 수 없는데 반품할 수 있게된다면 버그인 셈

    상태 전이 테스트에서는 클래스나 함수 레벨에서 단위 테스트를 끝내고 해당 클래스가 인스턴스가 되어 다른 함수나 인스턴스가 호출되는지를 확인 = 시스템 전체에 대한 테스트 인 셈, 조기 단계의 테스트보다는 후반 테스트의 범주에 포함되는 경우가 많음

    개발자라면 상태 전이에 관한 에러 처리나 예외 처리를 고려해야함, 또한 어떤 상태에서 다음 상태로 전이할 수 없는지 어떤 파라미터가 필요한지 에러 메세지를 표시할지에 대해 테스트 담당자에게 전달해야함


코드 기반 단위 테스트
=============

단위테스트 = 광범위하게 사용됨. 코드의 정확성을 확인하는 테스트인지 단위 기능에 관한 테스트인지를 명확하게 할 것


## 4.1 코드 기반 단위 테스트

- 함수의 커버리지 비율을 측정해 로직의 확실성을 확인하는 화이트박스 테스트 = 코드 기반 단위 테스트

*화이트박스 테스트 = 모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법


다음과 같은 항목 확인

- 프로그램을 실행하는 도중 시스템상의 이상 작동을 수행하지 않음(null pointer, 0으로 나누는 계산)
- 입력값과 그에 대응하는 기댓값을 출력
- 모든 분기가 올바르게 처리됨(경곗값 테스트)

## 4.2 명령 커버리지(C2)

**C0커버리지**라고도 부름

간단하게 설명하자면 테스트 기준(테스트에서 적어도 한번은 모든 명령문을 실행)을 세우고 모든 조건분기를 타도록함 = 그러나 이 경우 테스트할 수 없는 경로가 발생하기도함

-> 불완전한 테스트, 그래서 **조건 커버리지**를 같이 수행해야함


## 4.3 조건 커버리지(C1)

**C1 커버리지**, C0 커버리지의 문제를 해결하는 기법 = 대부분의 경우 이 커버리지 방법으로 수행하는 것이 좋음

간단하게 설명하자면 각각의 판정조건이 TRUE,FALSE인 결과를 적어도 1번씩 가지는 테스트 케이스를 작성하는 것

### 참고 예시

![alt text](week02/gayeon/image.png)


## 4.4 자주 발생하는 단위 테스트 오류

이전까지만보면 조건 커버리지면 만사 OK 같지만,
**함수의 in/out을 체크하고 함수가 그 책임과 의무를 달성하는지도 동시에 주의해야함**

그래서 입력값의 패턴을 100% 커버하고, 그에 대한 기대 처리가 올바른지를 체크하는 것이 효과적인 단위테스트


## 4.5 코드 기반 단위 테스트 작성법

### 테스트 주도 개발 (TDD) = 애자일 개발과 상성이 좋음!
- 실제 소스 코드를 작성하기 전에 테스트 케이스를 작성
- 모든 테스트 코드를 자동화
- 버그는 즉시 수정
- 전문 테스트 담당자를 투입

### 일반적인 테스트 방법

테스트 코드를 먼저 작성한 뒤 실제 함수 처리를 작성

**TDD의 단계**
1. 레드: 항상 실패하는 테스트를 작성(간단하게 메서드의 형태만 작성해두고)
2. 그린: 테스트를 통과할 정도의 최소한의 프로덕션 코드를 작성(올바르게 로직을 작성하고)
3. 리팩터: 테스트가 통과하면 프로덕션 코드를 리팩토링(개선을 한다)

PS) 레드 -> 그린 -> 리팩터 순으로 짜고 커밋할 것


## 4.6 커버리지 비율: 코드 기반 단위 테스트의 성패를 측정

자동차같은 미션 크리티컬 소프트웨어라면 100퍼의 커버리지가 필요하지만, 그 외의 소프트웨어라면 80퍼도 충분!(사실 어디서도 커버리지 비율의 적절한 목표에 대해서 정해놓지않음. 논문이든 ISO나 IEEE규격이든)

그러면 왜 80%가 충분하냐? 소스 코드의 20% 정도는 에러 핸들링 처리인 만큼 그 코드까지 단위테스트로 커버할 필요는 없기때문

구글 코드 커버리지와 관련한 내부 가이드 라인
- 60% : 허용 범위
- 75% : 권장
- 90% : 모범적

단위 테스트 효율화 : 쉬운 단위테스트
=============

커버리지 비율은 80:20(파레토 법칙)의 두 부분만 측정할 수 있다면 충분

+) 파레토 법칙이란 80:20 법칙이라고도 불리는데, 80%의 결과가 20%의 원인에 의해 발생한다는 것

## 5.1 코드 복잡도

### 소스 코드 복잡도란?

- 복잡도가 높음 = if 또는 switch 문이 많음
- 복잡도가 낮음 = if 또는 switch 문이 적음

복잡도가 높을수록 유지보수성은 낮아지고, 복잡도가 낮을수록 유지보수성 높아짐

**C(복잡도) = e(프로그램에 포함된 경로 수) - n(프로그램에 포함된 분기점 수) + 2**

이러한 예제코드가 있을때

```
let x = 1;  
while (x < 10) {  
  if (x % 2 === 0) {  
    console.log('x는 지금 짝수입니다!')  
  } else {  
    console.log('x는 지금 홀수입니다!')  
  }  
  x++;  
}

```

![alt text](week02/gayeon/image-1.png)

(출처 : https://velog.io/@bdbest72/%EC%BD%94%EB%93%9C-%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%A5%BC-%EC%B8%A1%EC%A0%95%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95)


이때 경로수(8) - 노드 갯수(7) + 2 이므로 복잡도는 3인셈

## 5.2 단위 테스트의 대상

버그를 완전히 없애는건 불가능! 소프트웨어는 여전히 중간에 동작이 중단되는 행업 현상을 겪음 -> 그런데 사실 소프트웨어가 사용자가 바라는 기능을 충분히 제공한다면 상관없음, 크게 중요하지도 않은 세세한 테스트를 하며 힘을 빼지 말것

개선이란 현재의 업무를 효율적으로 수행, 그리고 동시에 품질을 높이는 것임

그러면 어떻게?

### 단위 테스트할 범위를 선정

80:20 -> 소프트웨어의 20%부분에서 80%의 버그가 나옴(막연하게 생각하자면..)
최근 발표된 논문을 참고하자면 
**대부분의 버그는 소스 코드 파일의 약 10~20%의 변경횟수가 많은 파일에서 발생함**

그렇다면? 코드의 20%를 커버하면서 탐색적 테스트를 수행하면 테스트는 완료! 
그런데 그 20%를 어떻게 추출? -> 최근 변경 횟수에 가중치를 붙이고 과거에 변경된 파일은 가중치를 붙이지 않음

**핫스팟 사고방식**
핫스팟 = 버그가 발생하기 쉬운 정도를 수치화한 것
핫스팟 값이 큰 파일에서 버그가 발생한다고 봐도 됨. 계산은 아래와 같이 (식 첨부 안했는데..
무언가의 계산에 따라 값을 구하고, 그 값이 크면 소스 코드를 확인한다 정도로 생각하기)

### 독자적인 방법: 파일을 2개로 분리
고전적 방법에서는 파일 변경 횟수만 고려하지만, 필자는 단위 테스트 수행 우선순위 지표로 파일 행 수의 길이를 추가함. 파일의 최근 변경 횟수가 많고 행 수가 긴것 부터 단위 테스트를 수행(가중치를 추가하는 셈)

복잡도와 핫스팟 값을 구해 어디부터 수정해야할 지 확인할 것
예를 들어 환경 정의 파일일때는 복잡도가 높으나 핫스팟이 작을 수 있고
간단한 구조임에도 변경 횟수가 많은 경우도 있음

복잡도가 높고 핫스팟 값이 높다 = 리팩토링
복잡도 낮은데 핫스팟 값이 낮다 = 코드 재확인

리팩토링할 시간이 없다면요? -> 먼저 파일을 2개로 분리(진짜. 물리적으로. 코드를 뜯으란얘기)

코드가 긴 파일은 규모가 큰 클래스 이거나 깔끔한 구조를 만들지 못해 함수들의 쓰레기통(ㅋㅋ)이 된 경우가 많음 이걸 물리적으로 구분해놓으면 결국 정리하게 됨


PS)

- 블랙박스 테스트 : 요구사항에 사양에 따라 정의된 입력값과 출력값을 사용해 시스템 또는 컴포넌트가 사양대로 작동하는지 확인하는 테스트
- 화이트박스 테스트: 요구사항 사양에 따라 정의된 입력값과 출력값을 사용해 시스템 또는 컴포넌트가 사양대로 작동하는지를 코드 커벌히지를 통해 확인하는 테스트.

-> 본질적으로 블랙박스 테스트와 화이트박스 테스트는 같음(왜 같다고보지? 보통은 다른딩)

- 커버리지 비율 달성 : 커버리지 비율은 테스트가 소프트웨어 코드의 얼마나 많은 부분을 실행(또는 '커버')했는지를 수치적으로 나타내는 지표입니다. 
- 기댓값 체크 : 기댓값 체크는 테스트 케이스를 실행했을 때, 소프트웨어가 예상되는 특정 결과 또는 값을 반환하는지를 확인하는 과정
  -  입력 값: 테스트 실행에 사용되는 데이터입니다.
  -  기대 결과 (기댓값): 주어진 입력에 대해 시스템이 반환해야 하는 예상 출력 값입니다.
  

따라서, 커버리지 비율은 테스트가 소프트웨어 코드의 어느 부분을 검증했는지에 대한 양적 평가를 제공하는 반면, 기댓값 체크는 테스트의 질적 측면, 즉 소프트웨어가 올바른 결과를 반환하는지를 평가합니다. 두 개념은 서로 보완적이며, 소프트웨어 개발 과정에서 모두 중요한 역할을 합니다.


기능별 단위 테스트
=============

코드 기반의 단위 테스트말고 UI에서 기능(복잡한 기능)단위로 단위 테스트를 수행하고 싶은 경우

## 6.1 개발자가 확인할 단위 기능 테스트

기능 단위의 테스트 = 블랙박스 테스트

### 정렬 기능의 단위 테스트

정렬 기능을 생각한다고하면 하나하나 정렬하는 걸 생각해야할텐데
기능 단위의 단위 테스트 방법의 기본 요소를 고려해야함
- 단위 기능 경곗값
- 조합

**단위 기능 경곗값**
나이를 기준으로할 때
- 0세일때 프로그램이 에러 없이 처리할 수 있는가
- 그 경계에 있는 -1를 에러로 처리할 수 있는가
- 그리고 상한의 값은 몇인가
- 만약 나이에 알파벳이 포함되어 있다면 어떻게 될지?

또 다른 경곗값의 예로는
- 데이터의 건수가 0일때
- 데이터의 건수가 1일때
- 데이터의 건수가 매우 많을때

**조합**
일반적으로 조합할 때는 반드시 해당 조합에서 버그가 발생하기 쉬운가를 생각해야함 -> 데이터의 건수가 1인 경우를 확인했다면 2개의 요소를 조합해 기능이 제대로 동작하는지?

예를 들어 같은 나이일때는 그다음 기준인 입사 연도순으로 정렬, 입사 연도가 같을 때에는 순위대로 등 -> 먼저 데이터가 1과 2일때 확실하게 커버하고 n이라는 테스트 케이스를 적절한 개수로 한정해 작성할 수 있어야함

**단위 기능이 복잡한 경우는 자동화 테스트를 권장한다!**







