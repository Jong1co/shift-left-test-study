# Chapter 04

### 코드 기반 단위 테스트

함수의 커버리지 비율을 측정해 로직의 확실성을 확인하는 **화이트박스 테스트**

- 프로그램을 실행하는 도중, 시스템상의 이상 작동을 수행하지 않음
- 입력값과 그에 대응하는 기댓값을 출력함
- 모든 분기가 올바르게 처리됨 (경곗값 테스트)

### 명령 커버리지(C0 커버리지)와 조건 커버리지(C1 커버리지)

명령 커버리지(테스트 포괄설 수준)

- 테스트에서 적어도 한 번은 프로그램의 모든 명령문을 실행한다.
- 모든 명령문(조건을 의미하는 거 같음)을 실행한다면 조건 분기를 타지 않는 케이스는 테스트가 누락됨
- 이 때문에 명령 커버리지는 불완전 테스트라고 알려짐
- 그렇기에 확실한 조건 커버리지를 달성할 것을 권장

조건 커버리지

- 방법: 각각의 판정 조검이 true, false인 결과를 적어도 1번씩 가지는 테스트

```
if(con1 == 0){
  x = x + 1;
}

if(conf2 > 1){
  x = x * 2
}

```

위와 같은 분기를 가질 때, 조건 커버리지는 두 가지의 테스트 케이스를 가질 수 있음

- con1 = 0, con2 = 2
- con1 = 1, con2 = 0

[true, false], [false, true] 케이스만 테스트 해도 괜찮은가?
-> 위에서는 같은 변수가 두 개의 조건을 탔기 때문인 것 같음

**단위 테스트의 목적**

- 단위 수준에서의 처리 기능의 버그를 없애는 것
- 입력값의 패턴을 100% 커버하고, 그에 대한 기대 처리가 올바른지를 체크하는 것
- 커버리지가 높다고 좋은 테스트가 아님(조건 커버리지에 주력해야 함)

**TDD(테스트 주도 개발) 진행 단계**

1. 레드: 항상 실패하는 테스트 작성
2. 그린: 테스트를 통과할 정도의 최소한의 프로덕션 코드를 작성
3. 리팩터: 테스트가 통과하면 프로덕션 코드를 리팩터링

### 커버리지 비율

- 소프트웨어라면 80% 커버하면 됨
- 소스코드의 20%는 에러 핸들링 처리
- 에러 핸들링 코드까지 단위 테스트로 커버할 필요 없음
  - 그렇다면 에러 핸들링 코드 제외하고 전부 다 단위 테스트를 진행해야 하는가

**구글의 코드 커버리지 내부 가이드 라인**

- 커버리지 60%: 허용 범위
- 커버리지 75%: 권장
- 커버리지 90%: 모범적
- 낮은 코드 커버리지는 넓은 코드 영역이 테스트되어 있지 않음을 보증
- 높은 코드 커버리지라고 해서 품질이 높은 것은 아님(돌연변이 테스트를 사용하는 것도 방법)
  - 돌연변이 테스트는 무엇인가?
- 자주 업데이트되는 코드는 커버해야 함
- 레거시 코드라도 조금씩 커버리지 비율을 높여가는 것이 좋음

# Chapter 05

**80:20 법칙(파레토 법칙)이란?**

-> 80%의 결과가 20%의 원인에 의해 발생한다는 법칙

-> 상반되는 법칙으로 롱테일 법칙이 등장함

> 롱테일 법칙:
> 주목받지 못하는 다수가 핵심적인 소수보다 더 큰 가치를 창출하는 현상을 말한다. IT와 통신서비스의 발달로 시장의 중심이 소수(20%)에서 다수(80%)로 옮겨가고 있는 것을 말한다.

### 코드 복잡도

- if문, switch문이 많음: 복잡도가 높음
- if문, switch문이 적음: 복잡도가 낮음

-> 복잡도가 높을 수록 유지보수성은 낮아짐

C(복잡도) = 프로그램의 경로 수 - 프로그램의 분기점 수 + 2
-> 숫자야구 복잡도 확인해보자

### 단위테스트할 범위

> 소프트웨어의 버그는 구조상의 문제가 아니라 일정 기간에, 특히 최근에 여러차례 변경되었거나, 그 변경 횟수가 많은 파일에서 버그가 발생한다는 연구 결과 있음
>
> 그 이후 많은 파생 논문도 발표되었는데, 결국 대부분의 버그는 소스코드 파일의 약 10~20% 부분에서 발생한다는 것

즉, 가장 많이 변경되는 코드를 커버하면 된다는 뜻인듯

- 20%를 추출하는 계산식은 최근 변경 횟수에 가중치를 붙이고, 과거에 변경된 파일은 그만큼 가중치를 붙이지 않는 것
- 이를 수치화 한 것을 **핫스팟**이라고 부름
- 계산식이 있지만, 무언가의 계산에 따라 값을 구하고, 그 값이 크면 소스코드를 확인하다 정도로 생각해도 됨
  - 핫스팟 값을 쉽게 확인할 수 있는 도구가 있나..? 아니면 이 걸 다 계산해야 하나?

### 단위 테스트 우선순위 지표

1. 파일 행 수의 길이
2. 복잡도
3. 핫스팟

- 파일 행 수의 길이가 길다는 의미는 복잡도가 높다는 의미이고 이에 더해 핫스팟또한 높으면 무언가 액션을 취해야 함
- 파일 행 수의 길이가 길다면 먼저 **파일을 2개로 분리하기를 제안**
- 이러한 방법을 적용하면 시스템 테스트의 1/5 비용으로 오류를 줄일 수 있다고 설명

**블랙박스 테스트와 화이트박스 테스트**

필자의 정의:

- 블랙박스 테스트: 입력값과 출력값을 사용해 해당 컴포넌트가 작동하는지 테스트
- 화이트박스 테스트: 입력값과 출력값을 사용해 해당 컴포넌트가 작동하는지를 **코드 커버리지를 통해 확인하는 테스트**

# Chapter 06

**UI 단위 테스트**

아래 두 가지 테스트 진행하면 됨

- 단위 기능 경곗값
- 조합

**단위 기능 경곗값**

앞장에 계속 나왔던 경곗값 테스트<br/>

- 데이터의 경계를 테스트 해야 함
- 여기서 말하는 경계는 데이터이기도 하지만 데이터 건수도 포함됨

**조합**

조합 테스트를 고려할 때에는 1, 2, n개의 조합으로 테스트 해야 함<br/>
**또한 버그가 발생하기 쉬운 조합을 고려해야 함**

> 2 조합 테스트
>
> - 이름, 나이, 입사년도, 순위 필드 존재
> - 같은 이름인 두 명을 나이로 정렬했을 때, 정렬 되는지
> - 같은 나이일 때 입사 연도 기준으로 잘 정렬 되는지 등등

<br/>

**필자의 의견**

> 위와 같이 1, 2일 때 확실하게 커버하고 n이라는 테스트 케이스를 적절한 개수로 한정해 작성할 수 있으면 품질 측면에서 거의 문제가 없다는 필자의 의견
>
> 이 외의 곳에서 오류가 발생하는 것을 걱정하여 모든 케이스의 테스트를 전부 작성하는 것은 굉장히 많은 비용이 소모되고, 검출하기도 어려움
>
> 그래도 단위 기능이 복잡한 경우에는 자동화 테스트를 권장
>
> (Allpairs같은 도구를 의미하는 것 같음)
>
> **또한 조합테스트를 추가하기 전에 요구사항이 불명확함에 따른 오류는 아닌지 확인해보는 것이 중요**

<br/>

**의사 결정 테이블 테스트와 올페어 테스트**

올페어 테스트는 아래 둘 중 하나를 의미하는 것으로 예상

> chapter 3에서 찾아봤던 내용
>
> All combination testing : 모든 경우의 수를 전부 테스트함
>
> ⭐️ Pair-wise testing: 두 입력값의 조합을 모두 테스트 (대부분 결함이 2개 요소의 상호작용에서 발생하기 때문에 두개씩 조합하여 테스트함)

**의사 결정 테이블 테스트**

입력값의 조합에 따른 출력 값을 참과 거짓으로 표현하며 테스트를 디자인하는 기법
![스크린샷 2024-04-06 오전 9 39 56](https://github.com/Jong1co/shift-left-test-study/assets/95389265/78565987-c3a1-470f-8331-17460d0fb061)

즉, 테스트 경우의 수는 2의 n 제곱임

그러나 경우에 따라서는 여러가지 경우의 수를 줄일 수 있음
![image](https://github.com/Jong1co/shift-left-test-study/assets/95389265/9307a708-8459-4f64-87b3-3c6fd5b8ecd5)

신용카드, 계좌이체, 무통장 입금을 겹쳐서 사용할 수 없기 때문에 해당 케이스는 2개가 거짓이어야 유효한 테스트가 됨

(출처: https://brunch.co.kr/@jiwonleeqa/221)

<br/>

# 디자인 패턴

### 퍼사드 패턴:

> 라이브러리, 프레임워크 또는 다른 클래스들의 복잡한 집합에 대한 단순화된 인터페이스를 제공하는 구조 패턴

내 클래스들의 비즈니스 로직이 외부 라이브러리의 구현 세부 사항과 밀접하게 결합되기 때문에

- 이를 캡슐화하여 변경에 용이하게 하고,
- 코드의 나머지 부분을 숨겨 상호작용을 단순하게 구현하기 위해
- Random, Console이 따로 존재하는데 이를 Util이란 클래스 하나로 사용하기 위해 퍼사드 패턴 사용

추상화 한다는 뜻인듯

### 상태 패턴:

> 객체의 내부 상태가 변경될 때 해당 객체가 그의 행동을 변경할 수 있도록 하는 행동 패턴. 객체가 행동을 변경할 때 객체가 클래스를 변경한 것처럼 보일 수 있음
>
> (무슨 의미지?)
>
> (앞선 chapter에서 말한) 상태 전이 테스트 적용할 수 있을 거 같음

- 숫자 야구에서 상태를 `start`, `playing`, `end`로 정의하고 세 개 상태를 `Context`에서 관리하면 좋을듯

- 상태 패턴에서의 특정 상태들은 서로를 인식하고 한 상태에서 다른 상태로 전이를 시작할 수 있지만 전략들은 거의 대부분 서로에 대해 알지 못함
  - 잘 모르겠는 점 : 전략패턴과 다르게 상태는 의존관계를 제한하지 않고 콘텍스트의 상태를 마음대로 변경할 수 있도록 하는데, 그렇다면 상태들 사이에서 의존관계가 발생해 안 좋은 것이 아닌가?
  - 실제로 적용해보고 확인해봐야 할듯..
