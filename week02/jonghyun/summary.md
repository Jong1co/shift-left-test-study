# Chapter 04

### 코드 기반 단위 테스트

함수의 커버리지 비율을 측정해 로직의 확실성을 확인하는 **화이트박스 테스트**

- 프로그램을 실행하는 도중, 시스템상의 이상 작동을 수행하지 않음
- 입력값과 그에 대응하는 기댓값을 출력함
- 모든 분기가 올바르게 처리됨 (경곗값 테스트)

### 명령 커버리지(C0 커버리지)와 조건 커버리지(C1 커버리지)

명령 커버리지(테스트 포괄설 수준)

- 테스트에서 적어도 한 번은 프로그램의 모든 명령문을 실행한다.
- 모든 명령문(조건을 의미하는 거 같음)을 실행한다면 조건 분기를 타지 않는 케이스는 테스트가 누락됨
- 이 때문에 명령 커버리지는 불완전 테스트라고 알려짐
- 그렇기에 확실한 조건 커버리지를 달성할 것을 권장

조건 커버리지

- 방법: 각각의 판정 조검이 true, false인 결과를 적어도 1번씩 가지는 테스트

```
if(con1 == 0){
  x = x + 1;
}

if(conf2 > 1){
  x = x * 2
}

```

위와 같은 분기를 가질 때, 조건 커버리지는 두 가지의 테스트 케이스를 가질 수 있음

- con1 = 0, con2 = 2
- con1 = 1, con2 = 0

[true, false], [false, true] 케이스만 테스트 해도 괜찮은가?
-> 위에서는 같은 변수가 두 개의 조건을 탔기 때문인 것 같음

**단위 테스트의 목적**

- 단위 수준에서의 처리 기능의 버그를 없애는 것
- 입력값의 패턴을 100% 커버하고, 그에 대한 기대 처리가 올바른지를 체크하는 것
- 커버리지가 높다고 좋은 테스트가 아님(조건 커버리지에 주력해야 함)

**TDD(테스트 주도 개발) 진행 단계**

1. 레드: 항상 실패하는 테스트 작성
2. 그린: 테스트를 통과할 정도의 최소한의 프로덕션 코드를 작성
3. 리팩터: 테스트가 통과하면 프로덕션 코드를 리팩터링

### 커버리지 비율

- 소프트웨어라면 80% 커버하면 됨
- 소스코드의 20%는 에러 핸들링 처리
- 에러 핸들링 코드까지 단위 테스트로 커버할 필요 없음
  - 그렇다면 에러 핸들링 코드 제외하고 전부 다 단위 테스트를 진행해야 하는가

**구글의 코드 커버리지 내부 가이드 라인**

- 커버리지 60%: 허용 범위
- 커버리지 75%: 권장
- 커버리지 90%: 모범적
- 낮은 코드 커버리지는 넓은 코드 영역이 테스트되어 있지 않음을 보증
- 높은 코드 커버리지라고 해서 품질이 높은 것은 아님(돌연변이 테스트를 사용하는 것도 방법)
  - 돌연변이 테스트는 무엇인가?
- 자주 업데이트되는 코드는 커버해야 함
- 레거시 코드라도 조금씩 커버리지 비율을 높여가는 것이 좋음

# Chapter 05

**80:20 법칙(파레토 법칙)이란?**

-> 80%의 결과가 20%의 원인에 의해 발생한다는 법칙

-> 상반되는 법칙으로 롱테일 법칙이 등장함

> 롱테일 법칙:
> 주목받지 못하는 다수가 핵심적인 소수보다 더 큰 가치를 창출하는 현상을 말한다. IT와 통신서비스의 발달로 시장의 중심이 소수(20%)에서 다수(80%)로 옮겨가고 있는 것을 말한다.

### 코드 복잡도

- if문, switch문이 많음: 복잡도가 높음
- if문, switch문이 적음: 복잡도가 낮음

-> 복잡도가 높을 수록 유지보수성은 낮아짐

C(복잡도) = 프로그램의 경로 수 - 프로그램의 분기점 수 + 2
-> 숫자야구 복잡도 확인해보자

### 단위테스트할 범위

> 소프트웨어의 버그는 구조상의 문제가 아니라 일정 기간에, 특히 최근에 여러차례 변경되었거나, 그 변경 횟수가 많은 파일에서 버그가 발생한다는 연구 결과 있음
>
> 그 이후 많은 파생 논문도 발표되었는데, 결국 대부분의 버그는 소스코드 파일의 약 10~20% 부분에서 발생한다는 것

즉, 가장 많이 변경되는 코드를 커버하면 된다는 뜻인듯

- 20%를 추출하는 계산식은 최근 변경 횟수에 가중치를 붙이고, 과거에 변경된 파일은 그만큼 가중치를 붙이지 않는 것
- 이를 수치화 한 것을 **핫스팟**이라고 부름
- 계산식이 있지만, 무언가의 계산에 따라 값을 구하고, 그 값이 크면 소스코드를 확인하다 정도로 생각해도 됨
  - 핫스팟 값을 쉽게 확인할 수 있는 도구가 있나..? 아니면 이 걸 다 계산해야 하나?

### 단위 테스트 우선순위 지표

1. 파일 행 수의 길이
2. 복잡도
3. 핫스팟

- 파일 행 수의 길이가 길다는 의미는 복잡도가 높다는 의미이고 이에 더해 핫스팟또한 높으면 무언가 액션을 취해야 함
- 파일 행 수의 길이가 길다면 먼저 **파일을 2개로 분리하기를 제안**
- 이러한 방법을 적용하면 시스템 테스트의 1/5 비용으로 오류를 줄일 수 있다고 설명

**블랙박스 테스트와 화이트박스 테스트**

필자의 정의:

- 블랙박스 테스트: 입력값과 출력값을 사용해 해당 컴포넌트가 작동하는지 테스트
- 화이트박스 테스트: 입력값과 출력값을 사용해 해당 컴포넌트가 작동하는지를 **코드 커버리지를 통해 확인하는 테스트**
