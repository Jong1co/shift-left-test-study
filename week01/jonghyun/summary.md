### Chapter 01

**시프트-레프트(shift-left):**
전체 개발 과정에서 품질을 향상하는 중요한 활동을 최대한 조기에 설계하고, 코딩 단계에서도 수행하는 전략

- 필자의 의견:
  - 버그가 언젠가부터 마지막에 해결해야 할 문제처럼 다루어지고 있다.
- 필자가 생각하는 버그가 발생하는 이유:
  - 버그가 발생하는 이유는 사람이 요구사항을 작성하고,
  - 해당 요구사항의 10배 이상 분량의 코드를 작성하는 과정에서 그 코드가 엉망으로 만들어지가 때문

**애자일**:

- 유연하게 일을 진행하자 + 변화에 잘 대응하자라는 사상 또는 철학으로 이러한 사상을 계승한 것이 스크럼, 칸반 등등의 방법론

**스크럼:**

다양한 기능을 가진 팀이 처음부터 마지막까지 함께 작업한다.

(시프트-레프트와 스크럼을 관통하는 문장) 코딩이 끝나면 테스트 담당자가 테스트 하는 것이 아닌, 코딩하면서 동시에 테스트를 수행하는 것

> 내재된 불안정성, 자기조직화된 프로젝트 팀, 중첩된 개발 단계, 다중 학습, 유연한 관리 체계, 조직 내 학습 공유 등등

- 스크럼에서는 이게 필요함
- 팀이 하나가 되어 작업하는 만큼 팀원이 어떤 작업을 하는지 이해해야 함
- 분주하다면 도와줘야 함
- 그것이 스크럼 관점에서의 올바른 행동

### Chapter 02

**애자일 테스트:**

2주의 시간 제약이 있는 시프트-레프트에서

1. 역할을 분리 (개발자와 테스트 담당자)
2. 구체적인 작업 지침 분리 (개발자와 테스트 담당자)

그 중 개발자의 구체적인 작업 지침:

- 어떻게 지표를 달성할지에 관한 구체적인 활동
  - 방식: 코드 품질을 어떻게 충족할 것인지 등의 목표로서 정의된 지표를 달성하는 데 필요한 활동을 정의함
- 가장 중요한 것은 시스템 테스트를 어떻게 수행할 것인가 보다는 어떻게 정량적으로 측정할 것인가
  - 일정 수준 이상의 코드 커버리지 비율 달성

**시프트-레프트 모델:**

- 시스템 테스트, 마지막 이터레이션에서 모든 버그를 잡아내고자 하는 것은 케이퍼스 존스가 말하는 혼돈 상태
- **시프트-라이트**(스프트-레프트의 반대)는 일정에 맞춰 제품을 릴리즈 한다는 의미에서 큰 리스크

**혼돈상태에 빠지지 않기 위한 필자의 제안:**

- 요구사항 및 사용자 스토리의 명확화
- 클래스나 함수 구조를 간단하게 유지
- 단위 및 통합테스트 실행
- 리뷰 실시

**시프트-레프트 테스트의 장점:**

- 프로젝트 후반에 버그를 없애는 비용은 전반에 드는 비용의 수배에 달함
  - 요구사항에서 해결하면 1, 아키텍쳐에서 수정하면 3, 시스템 테스트에서 하면 10, 출시 후 수정하면 100 (공수가 그만큼 많이 들어감)
  - 즉, 요구사항과 설계 단계에서 버그 검출해야 함
    - 내 경험: 기능이 확실하게 정해지지 않고 개발만 진행했다가, 요구사항에 비어있는 부분이 있었고, 이때문에 여러 차례의 수정이 발생했음
  - 결론적으로 시간을 단축함
- 해결되지 않은 버그가 출시 후에 남겨질 리스크가 있음
  - 고객에게 신뢰성 높은 제품 제공
  - 일본 IPA에서 발표한 수치로 조기 단계에서 품질을 보증하는 편이 출시 후의 품질을 더 높인다.

**시프트 레프트의 관점:**

조기 코드 인스펙션, 리뷰, 반복 개발, 주기적 구축 등에 중심을 두면 결함 추출 곡선은 개발 초기 단계로 이동한다.

**조기품질을 높이지 못하는 이유:**

- 변명: 옳다는 것은 알고 있지만, 바빠서 그렇게 하는 것은 불가능하다.
- 반박:
  - 그럼 여기에서 궁금한 점이 품질은 높일 수 있는데 시간은 ?
  - 고객이 오류를 발견하지 못하도록 기도하는 것 vs 시간이 조금 더 걸리더라도 확실한 품질의 소프트웨어
  - 심지어 초반에 수정하는 것이 나중에 수정하는 것보다 더 공수가 적게 듬 (결론적으로 더 빨라질듯)
  - 근데 모든 요구사항을 조기에 올바르게 하는 것이 가능한가 ?
- 버그를 검출하는 작업은 단지 올바르게 코딩하는 것만으로는 불가능.
- 요구사항과 설계 단계에서 버그 검출해야 함 (이번에 또 느낌 .. role이 확실하게 정해지지 않고 개발만 진행했다가, 요구사항에 비어있는 부분이 있었고, 이때문에 여러 차례의 수정이 발생했음)

### Chapter 03

테스트 라이프 사이클에서 각 단계에서 적절한 테스트 방법을 수행해야 함

- **테스트 라이프 사이클:** 단위테스트 → 통합테스트 → 시스템 테스트
- **테스트 방법:** 경곗값 테스트, 상태 전이 테스트, 조합 테스트

**조합테스트** : 입력 값을 조합하여 테스트 케이스를 생성하고 테스트

- All combination testing : 모든 경우의 수를 전부 테스트함
- ⭐️ Pair-wise testing: 두 입력값의 조합을 모두 테스트 (대부분 결함이 2개 요소의 상호작용에서 발생하기 때문에 두개씩 조합하여 테스트함)
- Each choice testing: 입력 값을 최소 한 번 이상 테스트
- Base choice testing: 기본 입력 값으로만 테스트 (base를 하나 만들고, 하나씩만 변경하여 테스트 진행하는 방법)

Pari-wise 테스팅을 가장 많이 하고, 조합의 수가 증가하면 사람의 힘으로 테스트가 불가능하므로 Tool(Allpairs, PICT 등등..)을 사용하여 테스트한다고 함

**경곗값 테스트** (css 미디어쿼리를 예시로 들 수도 있겠다)

일반적으로 경계에서 버그가 발생함

- 닫힘 관계버그 (ex. ≥ 와 >)
- 잘못된 숫자 입력 및 오해 (ex. a ≥ 1과 a≥2)
- 경계가 없음 (ex.주석처리)
- 여분의 경계

**상태 전이 테스트**

상태에서 다른 상태로 넘어가기 위해서는 전이가 발생함. <br/>
현재 상태에서 다른 상태로 변경되는 것을 테스트

- 상태 전이 매트릭스를 사용함
- 상태 전이 테스트에서는
  1. 클래스나 함수 레벨에서 단위 테스트가 끝난 뒤
  2. 해당 클래스가 인스턴스가 되어 다른 함수나 인스턴스가 호출되는지 등을 확인

---

### 추가로 알아본 것

**탐색적 테스트**:

- 사전에 테스트 케이스를 작성하지 않고 테스트 대상을 자유롭게 탐색하면서 테스트를 수행
- 예상하지 못한 오류를 발견하는 데에 효과적임
- 공식 테스팅을 보완하는 측면에서 활용하거나 병행하는 것이 가장 좋음
